// Copyright 2016 Marapongo, Inc. All rights reserved.

package resource

import (
	"github.com/marapongo/mu/pkg/util/contract"
)

// TODO: cancellation.
// TODO: progress reporting.
// TODO: concurrency.
// TODO: handle output dependencies
// TODO: plan application.

// Plan is the output of analyzing resource graphs and contains the steps necessary to perform an infrastructure
// deployment.  A plan can be generated out of whole cloth from a resource graph -- in the case of new deployments --
// however, it can alternatively be generated by diffing two resource graphs -- in the case of updates to existing
// environments (presumably more common).  The plan contains step objects that can be used to drive a deployment.
type Plan interface {
	Steps() Step  // the first step to perform, linked to the rest.
	Apply() error // performs the operations specified in this plan.
}

// Step is a specification for a deployment operation.
type Step interface {
	Op() StepOp         // the operation that will be performed.
	Resource() Resource // the resource affected by performing this step.
	Next() Step         // the next step to perform, or nil if none.
	Apply() error       // performs the operation specified by this step.
}

// StepOp represents the kind of operation performed by this step.
type StepOp int

const (
	OpCreate StepOp = iota
	OpRead
	OpUpdate
	OpDelete
)

// NewPlan analyzes a resource graph rg compared to an optional old resource graph oldRg, and creates a plan that will
// carry out operations necessary to bring the old resource graph in line with the new one.  It is ok for oldRg to be
// nil, in which case the plan will represent the steps necessary for a brand new deployment from whole cloth.
func NewPlan(s Snapshot, old Snapshot) Plan {
	contract.Requiref(s != nil, "s", "!= nil")

	// If old is non-nil, we need to diff the two snapshots to figure out the steps to take.
	if old != nil {
		return newUpdatePlan(s, old)
	}

	// If old is nil, on the other hand, our job is easier: we simply create all resources from scratch.
	return newCreatePlan(s)
}

type plan struct {
	first *step // the first step to take
}

var _ Plan = (*plan)(nil)

func (p *plan) Steps() Step { return p.first }

func (p *plan) Apply() error {
	contract.Failf("Apply is not yet implemented")
	return nil
}

func newUpdatePlan(s Snapshot, old Snapshot) *plan {
	// First diff the snapshots; in a nutshell:
	//
	//     - Anything in s but not old is a create
	//     - Anything in old but not s is a delete
	//     - Anything in both s and old is inspected:
	//         . Any changed properties imply an update
	//         . Otherwise, we may need to read the resource
	//
	// There are some caveats:
	//
	//     - Any changes in dependencies are possibly interesting
	//     - Any changes in moniker are interesting (see note on stability in monikers.go)
	//
	contract.Failf("Update plans not yet implemented")
	return nil
}

func newCreatePlan(s Snapshot) *plan {
	// There is no old snapshot, so we are creating a plan from scratch.  Everything is a create.
	var head *step
	var tail *step
	for _, res := range s.Topsort() {
		step := &step{
			op:  OpCreate,
			res: res,
		}
		if tail == nil {
			contract.Assert(head == nil)
			head = step
			tail = step
		} else {
			tail.next = step
			tail = step
		}
	}
	return &plan{first: head}
}

type step struct {
	op   StepOp   // the operation to perform.
	res  Resource // the target of the operation.
	next *step    // the next step after this one in the plan.
}

var _ Step = (*step)(nil)

func (s *step) Op() StepOp         { return s.op }
func (s *step) Resource() Resource { return s.res }
func (s *step) Next() Step {
	if s.next == nil {
		return nil
	}
	return s.next
}

func (s *step) Apply() error {
	contract.Failf("Apply is not yet implemented")
	return nil
}
