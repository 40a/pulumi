// Copyright 2016 Marapongo, Inc. All rights reserved.

package resource

import (
	"github.com/marapongo/mu/pkg/util/contract"
)

// TODO: cancellation.
// TODO: progress reporting.
// TODO: concurrency.
// TODO: handle output dependencies
// TODO: plan application.

// Plan is the output of analyzing resource graphs and contains the steps necessary to perform an infrastructure
// deployment.  A plan can be generated out of whole cloth from a resource graph -- in the case of new deployments --
// however, it can alternatively be generated by diffing two resource graphs -- in the case of updates to existing
// environments (presumably more common).  The plan contains step objects that can be used to drive a deployment.
type Plan interface {
	Steps() Step  // the first step to perform, linked to the rest.
	Apply() error // performs the operations specified in this plan.
}

// Step is a specification for a deployment operation.
type Step interface {
	Op() StepOp         // the operation that will be performed.
	Resource() Resource // the resource affected by performing this step.
	Next() Step         // the next step to perform, or nil if none.
	Apply() error       // performs the operation specified by this step.
}

// StepOp represents the kind of operation performed by this step.
type StepOp int

const (
	OpCreate StepOp = iota
	OpRead
	OpUpdate
	OpDelete
)

// NewCreatePlan creates a plan for instantiating a new snapshot from scratch.
func NewCreatePlan(s Snapshot) Plan {
	contract.Requiref(s != nil, "s", "!= nil")
	return newCreatePlan(s)
}

// NewDeletePlan creates a plan for deleting an entire snapshot in its entirety.
func NewDeletePlan(s Snapshot) Plan {
	contract.Requiref(s != nil, "s", "!= nil")
	return newDeletePlan(s)
}

// NewUpdatePlan analyzes a a resource graph rg compared to an optional old resource graph oldRg, and creates a plan
// that will carry out operations necessary to bring the old resource graph in line with the new one.
func NewUpdatePlan(s Snapshot, old Snapshot) Plan {
	contract.Requiref(s != nil, "s", "!= nil")
	contract.Requiref(old != nil, "old", "!= nil")
	return newUpdatePlan(s, old)
}

type plan struct {
	first *step // the first step to take
}

var _ Plan = (*plan)(nil)

func (p *plan) Steps() Step { return p.first }

func (p *plan) Apply() error {
	contract.Failf("Apply is not yet implemented")
	return nil
}

func newCreatePlan(s Snapshot) *plan {
	// To create the resources, we must perform the operations in dependency order.  That is, we create the leaf-most
	// resource first, so that later resources may safely depend upon their dependencies having been created.
	var head *step
	var tail *step
	for _, res := range s.Topsort() {
		step := &step{
			op:  OpCreate,
			res: res,
		}
		if tail == nil {
			contract.Assert(head == nil)
			head = step
			tail = step
		} else {
			tail.next = step
			tail = step
		}
	}
	return &plan{first: head}
}

func newDeletePlan(s Snapshot) *plan {
	// To delete an entire snapshot, we must perform the operations in reverse dependency order.  That is, resources
	// that consume others should be deleted first, so dependencies do not get deleted "out from underneath" consumers.
	var head *step
	var tail *step
	tops := s.Topsort()
	for i := len(tops) - 1; i >= 0; i-- {
		res := tops[i]
		step := &step{
			op:  OpDelete,
			res: res,
		}
		if tail == nil {
			contract.Assert(head == nil)
			head = step
			tail = step
		} else {
			tail.next = step
			tail = step
		}
	}
	return &plan{first: head}
}

func newUpdatePlan(s Snapshot, old Snapshot) *plan {
	// First diff the snapshots; in a nutshell:
	//
	//     - Anything in s but not old is a create
	//     - Anything in old but not s is a delete
	//     - Anything in both s and old is inspected:
	//         . Any changed properties imply an update
	//         . Otherwise, we may need to read the resource
	//
	// There are some caveats:
	//
	//     - Any changes in dependencies are possibly interesting
	//     - Any changes in moniker are interesting (see note on stability in monikers.go)
	//
	contract.Failf("Update plans not yet implemented")
	return nil
}

type step struct {
	op   StepOp   // the operation to perform.
	res  Resource // the target of the operation.
	next *step    // the next step after this one in the plan.
}

var _ Step = (*step)(nil)

func (s *step) Op() StepOp         { return s.op }
func (s *step) Resource() Resource { return s.res }
func (s *step) Next() Step {
	if s.next == nil {
		return nil
	}
	return s.next
}

func (s *step) Apply() error {
	contract.Failf("Apply is not yet implemented")
	return nil
}
