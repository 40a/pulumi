// Copyright 2016 Marapongo, Inc. All rights reserved.

package resource

import (
	"github.com/marapongo/mu/pkg/util/contract"
)

// TODO: concurrency.
// TODO: handle output dependencies

// Plan is the output of analyzing resource graphs and contains the steps necessary to perform an infrastructure
// deployment.  A plan can be generated out of whole cloth from a resource graph -- in the case of new deployments --
// however, it can alternatively be generated by diffing two resource graphs -- in the case of updates to existing
// environments (presumably more common).  The plan contains step objects that can be used to drive a deployment.
type Plan interface {
	Steps() Step                                      // the first step to perform, linked to the rest.
	Apply(prog Progress) (error, Step, ResourceState) // performs the operations specified in this plan.
}

// Progress can be used for progress reporting.
type Progress interface {
	Before(step Step)
	After(step Step, err error, state ResourceState)
}

// Step is a specification for a deployment operation.
type Step interface {
	Op() StepOp                    // the operation that will be performed.
	Resource() Resource            // the resource affected by performing this step.
	Next() Step                    // the next step to perform, or nil if none.
	Apply() (error, ResourceState) // performs the operation specified by this step.
}

// StepOp represents the kind of operation performed by this step.
type StepOp int

const (
	OpCreate StepOp = iota
	OpRead
	OpUpdate
	OpDelete
)

// NewCreatePlan creates a plan for instantiating a new snapshot from scratch.
func NewCreatePlan(ctx *Context, s Snapshot) Plan {
	contract.Requiref(s != nil, "s", "!= nil")
	return newCreatePlan(ctx, s)
}

// NewDeletePlan creates a plan for deleting an entire snapshot in its entirety.
func NewDeletePlan(ctx *Context, s Snapshot) Plan {
	contract.Requiref(s != nil, "s", "!= nil")
	return newDeletePlan(ctx, s)
}

// NewUpdatePlan analyzes a a resource graph rg compared to an optional old resource graph oldRg, and creates a plan
// that will carry out operations necessary to bring the old resource graph in line with the new one.
func NewUpdatePlan(ctx *Context, s Snapshot, old Snapshot) Plan {
	contract.Requiref(s != nil, "s", "!= nil")
	contract.Requiref(old != nil, "old", "!= nil")
	return newUpdatePlan(ctx, s, old)
}

type plan struct {
	ctx   *Context // this plan's context.
	first *step    // the first step to take.
}

var _ Plan = (*plan)(nil)

func (p *plan) Steps() Step { return p.first }

// Provider fetches the provider for a given resource, possibly lazily allocating the plugins for it.  If a provider
// could not be found, or an error occurred while creating it, a non-nil error is returned.
func (p *plan) Provider(res Resource) (Provider, error) {
	t := res.Type()
	pkg := t.Package()
	return p.ctx.Provider(pkg)
}

// Apply performs all steps in the plan, calling out to the progress reporting functions as desired.
func (p *plan) Apply(prog Progress) (error, Step, ResourceState) {
	var step Step = p.first
	for step != nil {
		if prog != nil {
			prog.Before(step)
		}
		err, rst := step.Apply()
		if prog != nil {
			prog.After(step, err, rst)
		}
		if err != nil {
			return err, step, rst
		}
		step = step.Next()
	}
	return nil, nil, StateOK
}

func newCreatePlan(ctx *Context, s Snapshot) *plan {
	// To create the resources, we must perform the operations in dependency order.  That is, we create the leaf-most
	// resource first, so that later resources may safely depend upon their dependencies having been created.
	p := &plan{ctx: ctx}
	var prev *step
	for _, res := range s.Topsort() {
		step := &step{
			p:   p,
			op:  OpCreate,
			res: res,
		}
		if prev == nil {
			contract.Assert(p.first == nil)
			p.first = step
			prev = step
		} else {
			prev.next = step
			prev = step
		}
	}
	return p
}

func newDeletePlan(ctx *Context, s Snapshot) *plan {
	// To delete an entire snapshot, we must perform the operations in reverse dependency order.  That is, resources
	// that consume others should be deleted first, so dependencies do not get deleted "out from underneath" consumers.
	p := &plan{ctx: ctx}
	var prev *step
	tops := s.Topsort()
	for i := len(tops) - 1; i >= 0; i-- {
		res := tops[i]
		step := &step{
			p:   p,
			op:  OpDelete,
			res: res,
		}
		if prev == nil {
			contract.Assert(p.first == nil)
			p.first = step
			prev = step
		} else {
			prev.next = step
			prev = step
		}
	}
	return p
}

func newUpdatePlan(ctx *Context, s Snapshot, old Snapshot) *plan {
	// First diff the snapshots; in a nutshell:
	//
	//     - Anything in s but not old is a create
	//     - Anything in old but not s is a delete
	//     - Anything in both s and old is inspected:
	//         . Any changed properties imply an update
	//         . Otherwise, we may need to read the resource
	//
	// There are some caveats:
	//
	//     - Any changes in dependencies are possibly interesting
	//     - Any changes in moniker are interesting (see note on stability in monikers.go)
	//
	contract.Failf("Update plans not yet implemented")
	return nil
}

type step struct {
	p    *plan    // this step's plan.
	op   StepOp   // the operation to perform.
	res  Resource // the target of the operation.
	old  Resource // the old view of the resource (for updates only).
	next *step    // the next step after this one in the plan.
}

var _ Step = (*step)(nil)

func (s *step) Op() StepOp         { return s.op }
func (s *step) Resource() Resource { return s.res }
func (s *step) Next() Step {
	if s.next == nil {
		return nil
	}
	return s.next
}

func (s *step) Apply() (error, ResourceState) {
	// To apply this step, first fetch the provider for it.
	prov, err := s.p.Provider(s.res)
	if err != nil {
		return err, StateOK
	}

	// Now simply perform the operation of the right kind.
	switch s.op {
	case OpCreate:
		id, err, rst := prov.Create(s.res)
		if err != nil {
			return err, rst
		}
		s.res.SetID(id)
	case OpDelete:
		contract.Assertf(string(s.res.ID()) == "", "Expected resource to be created has no ID")
		if err, rst := prov.Delete(s.res); err != nil {
			return err, rst
		}
	case OpUpdate:
		id, err, rst := prov.Update(s.res, s.old)
		if err != nil {
			return err, rst
		} else if id != ID("") {
			// An update might need to recreate the resource, in which case the ID must change.
			// TODO: this could have an impact on subsequent dependent resources that wasn't known during planning.
			s.res.SetID(id)
		}
	default:
		contract.Failf("Unexpected step operation: %v", s.op)
	}

	return nil, StateOK
}
