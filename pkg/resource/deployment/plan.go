// Licensed to Pulumi Corporation ("Pulumi") under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// Pulumi licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package deployment

import (
	"github.com/golang/glog"

	"github.com/pulumi/lumi/pkg/compiler/binder"
	"github.com/pulumi/lumi/pkg/compiler/core"
	"github.com/pulumi/lumi/pkg/compiler/symbols"
	"github.com/pulumi/lumi/pkg/diag"
	"github.com/pulumi/lumi/pkg/resource"
	"github.com/pulumi/lumi/pkg/resource/plugin"
	"github.com/pulumi/lumi/pkg/tokens"
	"github.com/pulumi/lumi/pkg/util/contract"
	"github.com/pulumi/lumi/pkg/util/rendezvous"
)

// TODO[pulumi/lumi#106]: plan parallelism.

// Plan is the output of analyzing resource graphs and contains the steps necessary to perform an infrastructure
// deployment.  A plan can be generated out of whole cloth from a resource graph -- in the case of new deployments --
// however, it can alternatively be generated by diffing two resource graphs -- in the case of updates to existing
// environments (presumably more common).  The plan contains step objects that can be used to drive a deployment.
type Plan struct {
	diag      diag.Sink                        // the diagnostics sink to use.
	bindctx   *binder.Context                  // the binder context (for compiler operations).
	plugctx   *plugin.Context                  // the plugin context (for provider operations).
	old       *Snapshot                        // the old resource snapshot for comparison.
	olds      map[resource.URN]*resource.State // a map of all old resources.
	pkg       *symbols.Package                 // the package to evaluate.
	args      core.Args                        // the arguments used to compile this package.
	config    resource.ConfigMap               // the configuration variables for this package.
	analyzers []tokens.QName                   // the analyzers to run during this plan's generation.
}

// NewPlan creates a new deployment plan from a resource snapshot plus a package to evaluate.
//
// From the old and new states, it understands how to orchestrate an evaluation and analyze the resulting resources.
// The plan may be used to simply inspect a series of operations, or actually perform them; these operations are
// generated based on analysis of the old and new states.  If a resource exists in new, but not old, for example, it
// results in a create; if it exists in both, but is different, it results in an update; and so on and so forth.
//
// Note that a plan uses internal concurrency and parallelism in various ways, so it must be closed if for some reason
// a plan isn't carried out to its final conclusion.  This will result in cancelation and reclamation of OS resources.
func NewPlan(ctx *binder.Context, old *Snapshot, pkg *symbols.Package, args core.Args, config resource.ConfigMap,
	host plugin.Host, analyzers []tokens.QName) *Plan {
	if glog.V(7) {
		glog.V(7).Infof("Creating plan for pkg %v with #old=%v #analyzers=%v\n",
			pkg, len(old.Resources), len(analyzers))
	}

	// Produce a map of all old resources for fast resources.
	olds := make(map[resource.URN]*resource.State)
	for _, oldres := range old.Resources {
		urn := oldres.URN()
		contract.Assert(olds[urn] == nil)
		olds[urn] = oldres
	}

	return &Plan{
		diag:      ctx.Diag,
		bindctx:   ctx,
		plugctx:   plugin.NewContext(ctx.Diag, host),
		old:       old,
		olds:      olds,
		pkg:       pkg,
		args:      args,
		config:    config,
		analyzers: analyzers,
	}
}

const (
	evalParty = rendezvous.PartyA // the evaluator's rendezvous party (it goes first).
	planParty = rendezvous.PartyB // the planner's rendezvous party (it goes second).
)

func (p *Plan) Diag() diag.Sink                        { return p.diag }
func (p *Plan) BindCtx() *binder.Context               { return p.bindctx }
func (p *Plan) PlugCtx() *plugin.Context               { return p.plugctx }
func (p *Plan) Old() *Snapshot                         { return p.old }
func (p *Plan) Olds() map[resource.URN]*resource.State { return p.olds }
func (p *Plan) PkgName() tokens.PackageName            { return p.old.Pkg.Name() }
func (p *Plan) Namespace() tokens.QName                { return p.old.Namespace }
func (p *Plan) Pkg() *symbols.Package                  { return p.pkg }
func (p *Plan) Args() core.Args                        { return p.args }
func (p *Plan) Config() resource.ConfigMap             { return p.config }

// Provider fetches the provider for a given resource, possibly lazily allocating the plugins for it.  If a provider
// could not be found, or an error occurred while creating it, a non-nil error is returned.
func (p *Plan) Provider(res resource.Resource) (plugin.Provider, error) {
	t := res.Type()
	pkg := t.Package()
	return p.plugctx.Host.Provider(pkg)
}
